 //This program is written by tane.
 //We create it to check if the robot can go straight from white to black.

 #define OK LDR_SUCCESS

 #define MOVE_POWER 50         //0~100
 #define LIGHT_LIMIT 500       //0~1023

 mutex time_mutex;
 long init_time,time;

 typedef struct {
      float raw_data[100];
      float ave_data[90];
      float ave_max;
      float ave_min;
      float ave_border;
 } Dtcl;


 sub Left();
 sub Right();
 sub Fwd();
 sub Back();
 sub ResetClock();
 Dtcl CollectData();
 task clock();

 //////////////
 ///  task  ///
 //////////////

 //main
 task main(){
      //initial setting
      SetSensorType(IN_1,SENSOR_TYPE_LIGHT_ACTIVE);
      SetSensorMode(IN_1,SENSOR_MODE_RAW);
      ResetClock();
      StartTask(clock);
      Dtcl data;
      data = CollectData();
      

      
      //loop
      while(true){

      }
 }
 
 Dtcl CollectData(){
     Dtcl data_ = {};
     int i,j,sum = 0;
     Left();
     for(int i = 0; i < 100; i++){
            data_.raw_data[i] = SensorRaw(IN_3);
            Wait(50);
     }
     for(j = 0; j < 90; j++){
           for(i = j;i < j+10;i++){
                 sum += data_.raw_data[i];
           }
           data_.ave_data[j] = sum/10;
           
           if(data_.ave_max < data_.ave_data[j]){
                 data_.ave_max = data_.ave_data[j];
           }else if(data_.ave_min > data_.ave_data[j]){
                 data_.ave_min = data_.ave_data[j];
           }
     }
     data_.ave_border = data_.ave_min + ( data_.ave_max - data_.ave_min )*0.85;
     return data_;
 }
 
 //always update time
 task clock(){
      while(true){
           Acquire(time_mutex);
           time = CurrentTick() - init_time;
           Release(time_mutex);
      }
 }
 
 //////////////////
 //  subroutine  //
 //////////////////

 //turn left
 sub Left(){
     OnFwd(OUT_A,MOVE_POWER);
     OnRev(OUT_B,MOVE_POWER);
 }
 //turn right
 sub Right(){
     OnFwd(OUT_B,MOVE_POWER);
     OnRev(OUT_A,MOVE_POWER);
 }
 //go forward
 sub Fwd(){
     OnFwd(OUT_AB,MOVE_POWER);
 }
 //go back
 sub Back(){
     OnRev(OUT_AB,MOVE_POWER);
 }

 //reset clock
 sub ResetClock(){
     Acquire(time_mutex);
     init_time = CurrentTick();
     time = 0;
     Release(time_mutex);
 }







